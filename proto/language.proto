syntax = "proto3";

package build.stack.subzelle.language.v1beta1;

import "google/protobuf/struct.proto";

// Configurer is the interface for language or library-specific configuration
// extensions. Most (ideally all) modifications to Config should happen via this
// interface.

service Language {

  // Kinds returns a map of maps rule names (kinds) and information on how to
  // match and merge attributes that may be found in rules of those kinds. All
  // kinds of rules generated for this language may be found here.
  rpc Kinds(KindsRequest) returns(KindsResponse);

  // Loads returns .bzl files and symbols they define. Every rule generated by
  // GenerateRules, now or in the past, should be loadable from one of these
  // files.
  rpc Loads(LoadsRequest) returns(LoadsResponse);

  // GenerateRules extracts build metadata from source files in a directory.
  // GenerateRules is called in each directory where an update is requested in
  // depth-first post-order.
  //
  // args contains the arguments for GenerateRules. This is passed as a struct
  // to avoid breaking implementations in the future when new fields are
  // added.
  //
  // A GenerateResult struct is returned. Optional fields may be added to this
  // type in the future.
  //
  // Any non-fatal errors this function encounters should be logged using
  // log.Print.
  rpc GenerateRules(GenerateArgs) returns(GenerateResult);

  // RegisterFlags registers command-line flags used by the extension. This
  // method is called once with the root configuration when Gazelle starts.
  // RegisterFlags may set an initial values in Config.Exts. When flags are
  // set, they should modify these values.
  rpc RegisterFlags(RegisterFlagsRequest) returns(ConfigFlagSet);

  // CheckFlags validates the configuration after command line flags are
  // parsed. This is called once with the root configuration when Gazelle
  // starts. CheckFlags may set default values in flags or make implied
  // changes.
  rpc CheckFlags(ConfigFlagSet) returns(ConfigFlagSet);

  // KnownDirectives returns a list of directive keys that this Configurer can
  // interpret. Gazelle prints errors for directives that are not recoginized by
  // any Configurer.
  rpc KnownDirectives(KnownDirectivesRequest) returns(KnownDirectivesResponse);

  // Configure modifies the configuration using directives and other
  // information extracted from a build file. Configure is called in each
  // directory.
  //
  // c is the configuration for the current directory. It starts out as a copy
  // of the configuration for the parent directory.
  //
  // rel is the slash-separated relative path from the repository root to the
  // current directory. It is "" for the root directory itself.
  //
  // f is the build file for the current directory or nil if there is no
  // existing build file.
  rpc Configure(ConfigureRequest) returns(ConfigureResponse);
}

message RegisterFlagsRequest {
  // the name of the command
  string cmd = 1;

  // The initial config flag set
  ConfigFlagSet config_flag_set = 2;
}

message ConfigFlagSet {
  // The configuration state
  Config config = 1;

  // The set of flags to add to the flag.FlagSet
  repeated Flag flag = 2;
}

message CheckFlagsRequest {
  // The initial configuration state
  Config config = 1;

  // The flag state before validation
  repeated Flag flag = 2;
}

message KnownDirectivesRequest {}

message KnownDirectivesResponse { repeated string directive = 1; }

message ConfigureRequest {
  // the configuration for the current directory. It starts out as a copy of
  // the configuration for the parent directory.
  Config config = 1;

  // rel is the slash-separated relative path from the repository root to the
  // current directory. It is "" for the root directory itself.
  string rel = 2;

  // f is the build file for the current directory or nil if there is no
  // existing build file.
  File File = 3;
}

message ConfigureResponse {}

// Flag message models https://golang.org/pkg/flag/#Flag
message Flag {
  // The intended type of the flag
  enum Type {
    TYPE_UNKNOWN = 0; BOOL = 1; DURATION = 2; FLOAT_64 = 3; INT = 4; INT_64 = 5;
    STRING = 6;
    UINT = 7;
    UINT_64 = 8;
  }

  // The type of the flag
  Type type = 1;

  // The name of the flag
  string name = 2;

  // The help message
  string usage = 3;

  // The value as set
  string value = 4;

  // the default value (as text); for usage message
  string def_value = 5;
}

// Config holds information about how Gazelle should run. This is based on
// command line arguments, directives, other hints in build files.
//
// A Config applies to a single directory. A Config is created for the
// repository root directory, then copied and modified for each subdirectory.
//
// Config itself contains only general information. Most configuration
// information is language-specific and is stored in Exts. This information
// is modified by extensions that implement Configurer.
message Config {
  // RepoRoot is the absolute, canonical path to the root directory of the
  // repository with all symlinks resolved.
  string repo_root = 1;

  // RepoName is the name of the repository.
  string repo_name = 2;

  // ReadBuildFilesDir is the absolute path to a directory where
  // build files should be read from instead of RepoRoot.
  string read_build_files_dir = 3;

  // Write_build_filesDir is the absolute path to a directory where
  // build files should be written to instead of RepoRoot.
  string write_build_files_dir = 4;

  // Valid_build_fileNames is a list of base names that are considered valid
  // build files. Some repositories may have files named "BUILD" that are not
  // used by Bazel and should be ignored. Must contain at least one string.
  repeated string valid_build_file_names = 5;

  // ShouldFix determines whether Gazelle attempts to remove and replace usage
  // of deprecated rules.
  bool should_fix = 6;

  // IndexLibraries determines whether Gazelle should build an index of
  // libraries in the workspace for dependency resolution
  bool index_libraries = 7;

  // KindMap maps from a kind name to its replacement. It provides a way for
  // users to customize the kind of rules created by Gazelle, via
  // # gazelle:map_kind.
  map<string, MappedKind> kind_map = 8;

  // Repos is a list of repository rules declared in the main WORKSPACE file
  // or in macros called by the main WORKSPACE file. This may affect rule
  // generation and dependency resolution.
  // Repos []*rule.Rule 9

  // Langs is a list of language names which Gazelle should process.
  // An empty list means "all languages".
  repeated string langs = 10;

  // NOT IMPLEMENTED:
  //
  // Exts is a set of configurable extensions. Generally, each language
  // has its own set of extensions, but other modules may provide their own
  // extensions as well. Values in here may be populated by command line
  // arguments, directives in build files, or other mechanisms.
  // Exts map[string]interface{} 11
}

message MappedKind {
  string from_kind = 1;
  string kind_name = 2;
  string kind_load = 3;
}

// File provides editing functionality for a build file. You can create a new
// file with EmptyFile or load an existing file with LoadFile. After changes
// have been made, call Save to write changes back to a file.
message File {

  // NOT IMPLEMENTED
  //
  // File is the underlying build file syntax tree. Some editing operations
  // may modify this, but editing is not complete until Sync() is called.
  // repeated BzlFile file = 1;

  // NOT IMPLEMENTED
  //
  // function is the underlying syntax tree of a bzl file function.
  // This is used for editing the bzl file function specified by the
  // update-repos -to_macro option.
  // function *function

  // Pkg is the Bazel package this build file defines.
  string pkg = 1;

  // Path is the file system path to the build file (same as File.Path).
  string path = 2;

  // DefName is the name of the function definition this File refers to
  // if loaded with LoadMacroFile or a similar function. Normally empty.
  string def_name = 3;

  // Directives is a list of configuration directives found in top-level
  // comments in the file. This should not be modified after the file is read.
  repeated FileDirective directive = 4;

  // Loads is a list of load statements within the file. This should not
  // be modified directly; use Load methods instead.
  repeated Load load = 5;

  // Rules is a list of rules within the file (or function calls that look like
  // rules). This should not be modified directly; use Rule methods instead.
  repeated Rule rule = 6;

  // Content is the file's underlying disk content, which is recorded when the
  // file is initially loaded and whenever it is saved back to disk. If the file
  // is modified outside of Rule methods, Content must be manually updated in
  // order to keep it in sync.
  bytes content = 7;
}

message FileDirective {
  string key = 1;
  string value = 2;
}

// Load represents a load statement within a build file.
message Load {
  string name = 1;

  string module = 2;

  bool force_compact = 3;

  repeated LoadSymbol symbol = 4;
}

message LoadSymbol {
  string from = 1;
  string to = 2;
}

// Rule represents a rule statement within a build file.
message Rule {
  // the kind of rule (TODO: what is this?)
  string kind = 1;

  // the name of the rule
  string name = 2;

  // the rule structure encapsulated as a dynamically typed struct.
  google.protobuf.Struct fields = 3;
}

message KindsRequest {}

message KindsResponse { map<string, KindInfo> kinds = 1; }

message KindInfo {
  // MatchAny is true if a rule of this kind may be matched with any rule of
  // the same kind, regardless of attributes, if exactly one rule is present a
  // build file.
  bool match_any = 1;

  // MatchAttrs is a list of attributes used in matching. For example, for
  // go_library, this list contains "importpath". Attributes are matched in
  // order.
  repeated string match_attrs = 2;

  // NonEmptyAttrs is a set of attributes that, if present, disqualify a rule
  // from being deleted after merge.
  map<string, bool> non_empty_attrs = 3;

  // SubstituteAttrs is a set of attributes that should be substituted after
  // matching and before merging. For example, suppose generated rule A
  // references B via an "embed" attribute, and B matches against rule C. The
  // label for B in A's "embed" must be substituted with a label for C.
  // "embed" would need to be in this set.
  map<string, bool> substitute_attrs = 4;

  // MergeableAttrs is a set of attributes that should be merged before
  // dependency resolution. See rule.Merge.
  map<string, bool> mergeable_attrs = 5;

  // ResolveAttrs is a set of attributes that should be merged after
  // dependency resolution. See rule.Merge.
  map<string, bool> resolve_attrs = 6;
}

message LoadsRequest {}

message LoadsResponse { repeated LoadInfo Load = 1; }

// LoadInfo describes a file that Gazelle knows about and the symbols
// it defines.
message LoadInfo {
  string name = 1;
  repeated string symbols = 2;
  repeated string after = 3;
}

message GenerateArgs {
  // Config is the configuration for the directory where rules are being
  // generated.
  Config config = 1;

  // Dir is the canonical absolute path to the directory.
  string dir = 2;

  // Rel is the slash-separated path to the directory, relative to the
  // repository root ("" for the root directory itself). This may be used
  // as the package name in labels.
  string rel = 3;

  // File is the build file for the directory. File is nil if there is
  // no existing build file.
  File file = 4;

  // Subdirs is a list of subdirectories in the directory, including
  // symbolic links to directories that Gazelle will follow.
  // RegularFiles is a list of regular files including other symbolic
  // links.
  // GeneratedFiles is a list of generated files in the directory
  // (usually these are mentioned as "out" or "outs" attributes in rules).
  repeated string subdirs = 5;
  repeated string regular_files = 6;
  repeated string gen_files = 7;

  // OtherEmpty is a list of empty rules generated by other languages.
  repeated Rule other_empty = 8;
  // OtherGen is a list of generated rules generated by other languages.
  repeated Rule other_gen = 9;
}

message GenerateResult {
  repeated Rule gen = 1;
  repeated Rule empty = 2;
  repeated google.protobuf.Struct imports = 3;
}
